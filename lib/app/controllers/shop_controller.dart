import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:image_picker/image_picker.dart';
import '../models/product_model.dart';
import '../models/shop_model.dart';
import '../models/subscription_model.dart';
import '../services/shop_service.dart';
import '../controllers/auth_controller.dart';

class ShopController extends GetxController {
  final ShopService _shopService = ShopService();
  final AuthController _authController = Get.find<AuthController>();

  // Observable variables
  final RxList<ProductModel> _products = <ProductModel>[].obs;
  final Rx<SubscriptionModel?> _subscription = Rx<SubscriptionModel?>(null);
  final RxBool _isLoading = false.obs;
  final RxInt _totalViews = 0.obs;
  final RxInt _totalChats = 0.obs;
  final RxInt _activeProducts = 0.obs;

  // Getters
  List<ProductModel> get products => _products;
  SubscriptionModel? get subscription => _subscription.value;
  bool get isLoading => _isLoading.value;
  int get totalViews => _totalViews.value;
  int get totalChats => _totalChats.value;
  int get activeProducts => _activeProducts.value;
  int get remainingListings => subscription != null
      ? (subscription!.listingLimit == -1
            ? 999
            : subscription!.listingLimit - activeProducts)
      : 0;

  ShopModel? get currentShop => _authController.currentShop;

  @override
  void onInit() {
    super.onInit();
    if (currentShop != null) {
      loadShopData();
    }
  }

  Future<void> loadShopData() async {
    if (currentShop == null) return;

    try {
      _isLoading.value = true;

      // Load products
      await loadProducts();

      // Load subscription
      await loadSubscription();

      // Load analytics
      await loadAnalytics();
    } catch (e) {
      _showError('Failed to load shop data: $e');
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> loadProducts() async {
    if (currentShop == null) return;

    try {
      final products = await _shopService.getProductsByShop(currentShop!.id);
      _products.assignAll(products);
      _activeProducts.value = products.where((p) => p.isActive).length;
    } catch (e) {
      _showError('Failed to load products: $e');
    }
  }

  Future<void> loadSubscription() async {
    if (currentShop == null) return;

    try {
      final subscription = await _shopService.getSubscription(currentShop!.id);
      _subscription.value = subscription;
    } catch (e) {
      _showError('Failed to load subscription: $e');
    }
  }

  Future<void> loadAnalytics() async {
    if (currentShop == null) return;

    try {
      final analytics = await _shopService.getShopAnalytics(currentShop!.id);
      _totalViews.value = analytics['total_views'] ?? 0;
      _totalChats.value = analytics['total_chats'] ?? 0;
    } catch (e) {
      _showError('Failed to load analytics: $e');
    }
  }

  Future<bool> addProduct({
    required String name,
    required double price,
    required String category,
    required String description,
    required List<XFile> images,
  }) async {
    if (currentShop == null) return false;

    // Check listing limit
    if (remainingListings <= 0) {
      Get.snackbar(
        'Listing Limit Reached',
        'Upgrade your subscription to add more products',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.error,
        colorText: Get.theme.colorScheme.onError,
      );
      return false;
    }

    try {
      _isLoading.value = true;

      // Upload images
      final imageUrls = <String>[];
      for (final image in images) {
        final url = await _shopService.uploadProductImage(
          imagePath: image.path,
          shopId: currentShop!.id,
        );
        imageUrls.add(url);
      }

      // Create product
      final product = ProductModel(
        id: '', // Will be generated by database
        shopId: currentShop!.id,
        name: name,
        price: price,
        category: category,
        imageUrls: imageUrls,
        description: description,
        createdAt: DateTime.now(),
      );

      final createdProduct = await _shopService.createProduct(product);
      _products.add(createdProduct);
      _activeProducts.value++;

      Get.snackbar(
        'success'.tr,
        'Product added successfully',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.primary,
        colorText: Get.theme.colorScheme.onPrimary,
      );

      return true;
    } catch (e) {
      _showError('Failed to add product: $e');
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  Future<bool> updateProduct({
    required String productId,
    required String name,
    required double price,
    required String category,
    required String description,
    List<XFile>? newImages,
  }) async {
    try {
      _isLoading.value = true;

      final existingProduct = _products.firstWhere((p) => p.id == productId);
      List<String> imageUrls = List.from(existingProduct.imageUrls);

      // Upload new images if provided
      if (newImages != null && newImages.isNotEmpty) {
        for (final image in newImages) {
          final url = await _shopService.uploadProductImage(
            imagePath: image.path,
            shopId: currentShop!.id,
          );
          imageUrls.add(url);
        }
      }

      final updatedProduct = ProductModel(
        id: productId,
        shopId: existingProduct.shopId,
        name: name,
        price: price,
        category: category,
        imageUrls: imageUrls,
        description: description,
        isActive: existingProduct.isActive,
        createdAt: existingProduct.createdAt,
        updatedAt: DateTime.now(),
      );

      await _shopService.updateProduct(updatedProduct);

      // Update local list
      final index = _products.indexWhere((p) => p.id == productId);
      if (index != -1) {
        _products[index] = updatedProduct;
      }

      Get.snackbar(
        'success'.tr,
        'Product updated successfully',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.primary,
        colorText: Get.theme.colorScheme.onPrimary,
      );

      return true;
    } catch (e) {
      _showError('Failed to update product: $e');
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> deleteProduct(String productId) async {
    try {
      _isLoading.value = true;

      await _shopService.deleteProduct(productId);

      _products.removeWhere((p) => p.id == productId);
      _activeProducts.value = _products.where((p) => p.isActive).length;

      Get.snackbar(
        'success'.tr,
        'Product deleted successfully',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.primary,
        colorText: Get.theme.colorScheme.onPrimary,
      );
    } catch (e) {
      _showError('Failed to delete product: $e');
    } finally {
      _isLoading.value = false;
    }
  }

  Future<void> toggleProductStatus(String productId) async {
    try {
      final product = _products.firstWhere((p) => p.id == productId);
      final updatedProduct = ProductModel(
        id: product.id,
        shopId: product.shopId,
        name: product.name,
        price: product.price,
        category: product.category,
        imageUrls: product.imageUrls,
        description: product.description,
        isActive: !product.isActive,
        createdAt: product.createdAt,
        updatedAt: DateTime.now(),
      );

      await _shopService.updateProduct(updatedProduct);

      // Update local list
      final index = _products.indexWhere((p) => p.id == productId);
      if (index != -1) {
        _products[index] = updatedProduct;
      }

      _activeProducts.value = _products.where((p) => p.isActive).length;
    } catch (e) {
      _showError('Failed to update product status: $e');
    }
  }

  Future<bool> uploadPaymentProof(XFile proofImage) async {
    if (currentShop == null) return false;

    try {
      _isLoading.value = true;

      final proofUrl = await _shopService.uploadPaymentProof(
        imagePath: proofImage.path,
        shopId: currentShop!.id,
      );

      await _shopService.submitPaymentProof(
        shopId: currentShop!.id,
        proofImageUrl: proofUrl,
      );

      Get.snackbar(
        'success'.tr,
        'Payment proof uploaded successfully. Admin will verify shortly.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.primary,
        colorText: Get.theme.colorScheme.onPrimary,
      );

      return true;
    } catch (e) {
      _showError('Failed to upload payment proof: $e');
      return false;
    } finally {
      _isLoading.value = false;
    }
  }

  void _showError(String message) {
    Get.snackbar(
      'error'.tr,
      message,
      snackPosition: SnackPosition.BOTTOM,
      backgroundColor: Get.theme.colorScheme.error,
      colorText: Get.theme.colorScheme.onError,
    );
  }
}
